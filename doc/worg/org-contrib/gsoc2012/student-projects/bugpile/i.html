
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>iOrg - interactive Org</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="iOrg - interactive Org"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-05-26 18:56:14 CEST"/>
<meta name="author" content="Thorsten Jolitz"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>

<style type="text/css">#outline-container-introduction{ clear:both; }</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:70%;white-space:nowrap;">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="http://orgmode.org/worg/"> HOME </a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">iOrg - interactive Org</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#appl-design">Application Design</a>
<ul>
<li><a href="#loc-ref-softw-arch">Locally Refining the Software Architecture</a></li>
<li><a href="#transform-rules">The Transformation Rules</a>
<ul>
<li><a href="#transform-general-consid">General considerations</a></li>
<li><a href="#transform-dom-class-mod">Domain Class Model</a></li>
<li><a href="#transform-rules-soa">Software Oriented Activities (SOA)</a></li>
<li><a href="#transform-complex-syst-act">Complex System Activities</a></li>
<li><a href="#summary-transform-rules">Summary of Transformation Rules</a></li>
</ul>
</li>
<li><a href="#class-model">Class Model</a></li>
<li><a href="#refine-logic">Refining the Logic</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-appl-design" class="outline-2">
<h2 id="appl-design"><a name="sec-1" id="sec-1"></a>Application Design</h2>
<div class="outline-text-2" id="text-appl-design">


</div>

<div id="outline-container-loc-ref-softw-arch" class="outline-3">
<h3 id="loc-ref-softw-arch"><a name="sec-1-1" id="sec-1-1"></a>Locally Refining the Software Architecture</h3>
<div class="outline-text-3" id="text-loc-ref-softw-arch">

</div>

</div>

<div id="outline-container-transform-rules" class="outline-3">
<h3 id="transform-rules"><a name="sec-1-2" id="sec-1-2"></a>The Transformation Rules</h3>
<div class="outline-text-3" id="text-transform-rules">


</div>

<div id="outline-container-transform-general-consid" class="outline-4">
<h4 id="transform-general-consid"><a name="sec-1-2-1" id="sec-1-2-1"></a>General considerations</h4>
<div class="outline-text-4" id="text-transform-general-consid">

<p>Emacs Lisp is not an object-oriented programming language, and the
whole Emacs environment and philosophy is based on functions, not on
objects. However, we used object-oriented terminology throughout this
tutorial. Why did we do that, and how can we map the object-oriented
concepts and terms into the Emacs and Org-mode world? 
</p>
<p>
Modeling a real world system in terms of objects is convenient,
because the real world is composed of interacting and related objects
(that's at least how humans perceive it). Since the object-oriented
approach has enjoyed the status of a quasi industry standard in the
last decades, there exist well established methodology one can rely on
when modeling a web application in terms of classes and objects.
</p>
<p>
However, the resulting artefacts of the object-oriented requirements
analysis and software specification must be transformed into a
software design that fits with the language and runtime environment
the system will be implemented in. Some creativity and a lot of
pragmatism is necessary to benefit from such a transformation without
complicating things unnecessary.
</p>
<p>
While the specific transformation rules will be described in the
following subsections, the following statement holds in general for
the iOrg framework:
</p>
<blockquote>

<p>Terminology from the object-oriented world is used in a very loose and
broad sense in the iOrg framework. When talking about classes,
objects, methods, inheritance etc, we do not talk about those well
defined language constructs and concepts known from <i>Smalltalk</i> and
its successors, but rather about some artefacts from the Emacs and Org-mode
world that might serve to implement some of the ideas associated with
object-orientation. 
</p>
</blockquote>


</div>

</div>

<div id="outline-container-transform-dom-class-mod" class="outline-4">
<h4 id="transform-dom-class-mod"><a name="sec-1-2-2" id="sec-1-2-2"></a>Domain Class Model</h4>
<div class="outline-text-4" id="text-transform-dom-class-mod">



</div>

<div id="outline-container-class-obj-inherit" class="outline-5">
<h5 id="class-obj-inherit"><a name="sec-1-2-2-1" id="sec-1-2-2-1"></a>Classes, Objects and Inheritance</h5>
<div class="outline-text-5" id="text-class-obj-inherit">


<p>
The <i>domain class model</i> of the requirements analysis and the software
specification phase is very similar to an <i>entity-relationship</i> model,
because classes (entities) and their relationships are modeled (with
attributes, but without methods).
</p>
<p> 
What is a class and and what is an object in the context of the iOrg
framework? How are the relationships between objects implemented?
</p>
<p>
We define as a convention that each object (entitiy) is represented by
one .org file in the <i>objects</i> directory. Relations with other objects
are realized via attribute values, i.e. other objects can represent
valid values of certain object attributes.
</p>
<p>
To introduce classes and inheritance in this framework, we make use of
the attribute inheritance of Org-mode:
</p>
<blockquote>

<p>The outline structure of Org mode documents lends itself to an
inheritance model of properties: if the parent in a tree has a certain
property, the children can inherit this property.
</p>
</blockquote>


<p>
Thus, a class hierarchy is constructed by building an outline tree
starting from the root class and promoting each subsequent subclass
one level. The following function is used to <code>get</code> the properties:
</p>
<blockquote>

<p>&ndash; Function: org-entry-get pom property &amp;optional inherit
    Get value of PROPERTY for entry at point-or-marker POM.  By
    default, this only looks at properties defined locally in the
    entry.  If INHERIT is non-nil and the entry does not have the
    property, then also check higher levels of the hierarchy.  If
    INHERIT is the symbol `selective', use inheritance if and only if
    the setting of `org-use-property-inheritance' selects PROPERTY for
   inheritance.
</p>
</blockquote>


<p>
Property inheritance seems natural in this construct, but may slow
things down:
</p>
<blockquote>

<p>Org mode does not turn [attribute inheritance] on by default, because
it can slow down property searches significantly and is often not
needed. However, if you find inheritance useful, you can turn it on by
setting the variable `org-use-property-inheritance'. It may be set to
`t' to make all properties inherited from the parent, to a list of
properties that should be inherited, or to a regular expression that
matches inherited properties. If a property has the value `nil', this
is interpreted as an explicit undefine of the property, so that
inheritance search will stop at this value and return `nil'.
</p>
</blockquote>


<p>
Therefore, iOrg offers an alternative method for building outline
trees with attribute inheritance (<i>speed inheritance</i>). It simply
copies all the properties of the parent entries into the property
drawer of the last node in the objects outline hierarchy, maintaining
their order. 
</p>
</div>

</div>

<div id="outline-container-class-vs-attr" class="outline-5">
<h5 id="class-vs-attr"><a name="sec-1-2-2-2" id="sec-1-2-2-2"></a>Classes vs Attributes</h5>
<div class="outline-text-5" id="text-class-vs-attr">

<p>When designing a class hierarchy, it is often necessary to decide if
the differences between two real-world classes should be modeled by
inserting a discriminating attribute into one software class (e.g.
attribute <code>color</code> in class <code>car</code>, with values white, green and black)
or by specialing a general superclass into several subclasses (e.g.
let subclasses <code>white-car</code>, <code>green-car</code> and <code>black-car</code> inherit from
superclass <code>car</code>). 
</p>
<p>
While there are more sophisticated guidelines how to tackle this
decision in the literature, we will restrict ourselves to common
sense: "Does it make sense to introduce more (sub-) classes to
discriminate between variations of an real-world object?"
</p>
<p>
As an example, let us consider the user hierarchy of bugpile. There
are three types of users, <i>user</i>, <i>assignee</i> and <i>admin</i>. Since a
bugtracker should make it easy to participate in improving software,
only minimal information is asked for in the registration process
(name and email). Thus, the user types are different only in what they
are allowed to do in the system, in their <i>permissions</i>.
</p>
<p>
Following the example of well-established software systems, we don't
hardcode the permissions into the users, but rather define <i>roles</i>
with certain <i>permissions</i> and then assign the <i>users</i> to one or more
roles.  
</p>
<p>
The next graphic shows the relation between bugpile users in a
very schematic way:
</p>


<p>
<img src="../../../../images/gsoc/2012/bugpile/bugpile-users.png"  alt="../../../../images/gsoc/2012/bugpile/bugpile-users.png" />
</p>

<p>
This schematic relation between users could be translated into one of
the following two class models:
</p>


<p>
<img src="../../../../images/gsoc/2012/bugpile/bugpile-users-class-model-subclass.png"  alt="../../../../images/gsoc/2012/bugpile/bugpile-users-class-model-subclass.png" />
</p>


<p>
<img src="../../../../images/gsoc/2012/bugpile/bugpile-users-class-model-attr.png"  alt="../../../../images/gsoc/2012/bugpile/bugpile-users-class-model-attr.png" />
</p>

<p>
When using <i>subclassing</i>, we need three classes and one object for every user
(instance). In iOrg, each class is simply represented by one .org file
with one entry and an attribute drawer:
</p>



<pre class="src src-org"><span class="org-comment"># class user</span>
<span class="org-org-level-1">* user</span>
<span class="org-org-special-keyword">  :PROPERTIES:</span>
  <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">root</span>
  <span class="org-org-special-keyword">:name:</span>     <span class="org-org-property-value">&lt;&lt;name&gt;&gt;</span>
  <span class="org-org-special-keyword">:email:</span>    <span class="org-org-property-value">&lt;&lt;email&gt;&gt;</span>
<span class="org-org-special-keyword">  :END:</span>
</pre>



<pre class="src src-org"><span class="org-comment"># class assignee</span>
 * assignee
  <span class="org-org-code">: PROPERTIES:</span>
  <span class="org-org-code">: super:    user</span>
  <span class="org-org-code">: assigneePermissions_ALL: reopen_task edit_task close_task</span>
  <span class="org-org-code">: assigneePermissions: &lt;&lt;permission&gt;&gt;</span>
  <span class="org-org-code">: END:</span>
</pre>



<pre class="src src-org"><span class="org-comment"># class admin</span>
<span class="org-org-level-1">* admin</span>
<span class="org-org-special-keyword">  :PROPERTIES:</span>
  <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">assignee</span>
  <span class="org-org-special-keyword">:adminPermissions_ALL:</span> <span class="org-org-property-value">create_project edit_project add_assignee assign_assignee</span>
  <span class="org-org-special-keyword">:adminPermissions:</span> <span class="org-org-property-value">&lt;&lt;permission&gt;&gt;</span>
<span class="org-org-special-keyword">  :END:</span>
</pre>


<p>
If we want to instantiate a new <i>admin</i>, we have to create a new admin
object. Each object is implemented as one .org file with as many
entries as there are superclasses of the instantiated class. 
</p>



<pre class="src src-org"><span class="org-comment"># object admin henry</span>
<span class="org-org-level-1">* user</span>
<span class="org-org-special-keyword">  :PROPERTIES:</span>
  <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">root</span>
  <span class="org-org-special-keyword">:name:</span>     <span class="org-org-property-value">henry</span>
  <span class="org-org-special-keyword">:email:</span>    <span class="org-org-property-value">henry@special.com</span>
<span class="org-org-special-keyword">  :END:</span>
<span class="org-org-level-2">** assignee</span>
<span class="org-org-special-keyword">   :PROPERTIES:</span>
   <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">user</span>
   <span class="org-org-special-keyword">:assigneePermissions_ALL:</span> <span class="org-org-property-value">reopen_task edit_task close_task</span>
   <span class="org-org-special-keyword">:assigneePermissions:</span> <span class="org-org-property-value">edit_task</span>
<span class="org-org-special-keyword">   :END:</span>
<span class="org-org-level-3">*** admin</span>
<span class="org-org-special-keyword">  :PROPERTIES:</span>
  <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">assignee</span>
  <span class="org-org-special-keyword">:adminPermissions_ALL:</span> <span class="org-org-property-value">create_project edit_project add_assignee assign_assignee</span>
  <span class="org-org-special-keyword">:adminPermissions:</span> <span class="org-org-property-value">edit_project</span>
  <span class="org-org-special-keyword">:adminPermissions+:</span> <span class="org-org-property-value">create_project</span>
<span class="org-org-special-keyword">  :END:</span>
</pre>


<p>
One could say that the superclasses are 'injected' into the object
file as hierarchical parent entries of the object entry. If attribute
inheritance is turned on, all the attributes of the parent entries
become attributes of the object entry too, i.e. the new admin Henry
has a name, an email as well as the (assignee-) permission to edit
tasks. Using <i>speed inheritance</i> to speed up the attribute search, we
would simply move all the attributes from the parent entries into the
attribute drawer of the object entry:
</p>



<pre class="src src-org"><span class="org-comment"># object admin henry (with 'speed-inheritance')</span>
<span class="org-org-level-1">* user</span>
<span class="org-org-special-keyword">  :PROPERTIES:</span>
  <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">root</span>
<span class="org-org-special-keyword">  :END:</span>
<span class="org-org-level-2">** assignee</span>
<span class="org-org-special-keyword">   :PROPERTIES:</span>
   <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">user</span>
<span class="org-org-special-keyword">   :END:</span>
<span class="org-org-level-3">*** admin</span>
<span class="org-org-special-keyword">  :PROPERTIES:</span>
  <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">assignee</span>
  <span class="org-org-special-keyword">:name:</span>     <span class="org-org-property-value">henry</span>
  <span class="org-org-special-keyword">:email:</span>    <span class="org-org-property-value">henry@special.com</span>
  <span class="org-org-special-keyword">:assigneePermissions_ALL:</span> <span class="org-org-property-value">reopen_task edit_task close_task</span>
  <span class="org-org-special-keyword">:assigneePermissions:</span> <span class="org-org-property-value">edit_task</span>
  <span class="org-org-special-keyword">:adminPermissions_ALL:</span> <span class="org-org-property-value">create_project edit_project add_assignee assign_assignee</span>
  <span class="org-org-special-keyword">:adminPermissions:</span> <span class="org-org-property-value">edit_project</span>
  <span class="org-org-special-keyword">:adminPermissions+:</span> <span class="org-org-property-value">create_project</span>
<span class="org-org-special-keyword">  :END:</span>
</pre>


<p>
This is how inheritance and instantiation work in iOrg. But does it
make sense to apply these concepts to the bugpile user hierarchy? We
had to construct a somehow contrived example to demonstrate the
implementation of classes and objects in iOrg. But really, in this
case, a solution based on subclassing is much to complicated for the
simple problem at hand. It seems more natural to simply introduce
another attribute <code>role</code> in the <i>user</i> class and discriminate the
different user types by the value of this attribute. We define the
class <code>role</code> that declares all possible roles in the system. Another
class <code>permissions</code> assigns permissions to each of the roles.
</p>



<pre class="src src-org"><span class="org-comment"># class permissions</span>
<span class="org-org-level-1">* permissions</span>
<span class="org-org-special-keyword">  :PROPERTIES:</span>
  <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">root</span>
  <span class="org-org-special-keyword">:user:</span>     <span class="org-org-property-value">unpriviledged</span>
  <span class="org-org-special-keyword">:assignee:</span> <span class="org-org-property-value">close_task reopen_task edit_task self_assign_task</span>
  <span class="org-org-special-keyword">:admin:</span>    <span class="org-org-property-value">create_project edit_project search_user action_on_user assign_task</span>
<span class="org-org-special-keyword">  :END:</span>
</pre>



<pre class="src src-org"><span class="org-comment"># class role</span>
<span class="org-org-level-1">* role</span>
<span class="org-org-special-keyword">  :PROPERTIES:</span>
  <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">root</span>
  <span class="org-org-special-keyword">:role_ALL:</span> <span class="org-org-property-value">user assignee admin</span>
<span class="org-org-special-keyword">  :END:</span>
</pre>


<p>
Then we add the <code>role</code> attribute to the <code>user</code> class. 
</p>



<pre class="src src-org"><span class="org-comment"># class user</span>
<span class="org-org-level-1">* user</span>
<span class="org-org-special-keyword">  :PROPERTIES:</span>
  <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">role</span>
  <span class="org-org-special-keyword">:name:</span>     <span class="org-org-property-value">&lt;&lt;name&gt;&gt;</span>
  <span class="org-org-special-keyword">:email:</span>    <span class="org-org-property-value">&lt;&lt;email&gt;&gt;</span>
  <span class="org-org-special-keyword">:role:</span>     <span class="org-org-property-value">&lt;&lt;role&gt;&gt;</span>
<span class="org-org-special-keyword">  :END:</span>
</pre>


<p>
To instantiate user object 'Henry' with role <i>admin</i> we only have
to 'inject' one superclass <code>role</code> and assign the value
'admin' to the attribute <code>role</code>. 
</p>



<pre class="src src-org"><span class="org-comment"># object admin henry</span>
<span class="org-org-level-1">* role</span>
<span class="org-org-special-keyword">  :PROPERTIES:</span>
  <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">root</span>
  <span class="org-org-special-keyword">:role_ALL:</span> <span class="org-org-property-value">user assignee admin</span>
<span class="org-org-special-keyword">  :END:</span>
<span class="org-org-level-2">** user</span>
<span class="org-org-special-keyword">  :PROPERTIES:</span>
  <span class="org-org-special-keyword">:super:</span>    <span class="org-org-property-value">role</span>
  <span class="org-org-special-keyword">:name:</span>     <span class="org-org-property-value">henry</span>
  <span class="org-org-special-keyword">:email:</span>    <span class="org-org-property-value">henry@special.com</span>
  <span class="org-org-special-keyword">:role:</span>     <span class="org-org-property-value">admin</span>
<span class="org-org-special-keyword">  :END:</span>
</pre>


<p>
In more complicated cases, subclassing can represent a convenient way
to assure a consistent attribute definitions for related types of
objects. For our simple example, introducing a new attribute to
discriminate between different types of user objects was a more
natural solution. 
</p>
<p>
We use subclassing mostly to achieve attribute inheritance, not
necessarily to establish class hierarchies based on specialisation and
generalisation (like 'an admin IS a user'). A user is not (a
specialisation of) a role, but nevertheless it is convenient to
declare 'role' as a superclass of 'user' to inherit the role_ALL
attribute definition.
</p>
</div>
</div>

</div>

<div id="outline-container-transform-rules-soa" class="outline-4">
<h4 id="transform-rules-soa"><a name="sec-1-2-3" id="sec-1-2-3"></a>Software Oriented Activities (SOA)</h4>
<div class="outline-text-4" id="text-transform-rules-soa">

<p>We used software oriented activity diagrams for integrated modeling of
user activities and the related UI. Thus, these diagrams need to be
transformed into the <i>controller</i>, <i>view</i> and <i>logic</i> component of the
iOrg framework.
</p>
<p>
Each activitiy diagram (use case) is transformed into one
<code>&lt;&lt;use-case-name&gt;&gt;-controller.el</code> file in the <i>controller</i> directory
(e.g. <code>open-new-task-controller.el</code>). For each system activitiy in the
SOA, one handler function is added to this controller file (e.g.
<code>show-open-new-task-form-handler(...)</code> and
<code>store-new-task-handler(...)</code>). 
</p>
<p>
Each <i>scene</i> in the SOA is translated into one
<code>&lt;&lt;user-activity-name&gt;&gt;-scene.org</code> file in the use case subdirectory
of the <i>view</i> directory (e.g. <code>define-user-search-criteria-scene.org</code>
in the <i>view/search-users</i> directory). 
</p>
</div>

</div>

<div id="outline-container-transform-complex-syst-act" class="outline-4">
<h4 id="transform-complex-syst-act"><a name="sec-1-2-4" id="sec-1-2-4"></a>Complex System Activities</h4>
<div class="outline-text-4" id="text-transform-complex-syst-act">


<p>
If there is complex logic involved in a case (a system activity
marked with the pitchfork symbol â‹” as subactivity in a SOA) , a
<code>&lt;&lt;use-case-name&gt;&gt;-logic.el</code> file is added to the <i>logic</i> directory
(e.g. <code>search-task-list-logic.el</code>). The 'atomic' system activities
that constitute the complex system activitiy are translated into
worker functions in this file (e.g. <code>search-task-worker(...)</code> and
<code>prepare-result-list-worker(...)</code>).
</p>
<p>
The <i>worker</i> functions from the <i>logic</i> component are independent of
the client used, they represent basic application functionality needed
when accesssing the application from a web-browser as well as directly
from Emacs. The <i>handler</i> functions from the <i>controller</i> component
are only used by the web-client, their sole razon d'etre is the
handling of http requests. The application should still work without
them, if accessed directly from Emacs. 
</p>
<p>
Thus, <i>handler</i> functions are a bit like managers - there are many of
them and they need a lot of attention, but things still work without
them (accesssing the application from Emacs). They don't do the real
work, they just coordinate and manage things with regards to the
web-clients. On the other hand, <i>worker</i> functions are more like
engineers, they do the hard work in the background, and without them
the system does not work anymore.
</p>

</div>

<div id="outline-container-search-tasks-syst-act-design" class="outline-5">
<h5 id="search-tasks-syst-act-design"><a name="sec-1-2-4-1" id="sec-1-2-4-1"></a>Search Tasks</h5>
<div class="outline-text-5" id="text-search-tasks-syst-act-design">


<p>
Since bugpile uses a dVCS as database for its textfiles, a query for a
task might include task name, commit (date or id), author, state of
the task, and other information that can't be accessed simply by
searching for the task file in the file system. The search
facilities should be available independently from the frontend used,
i.e. power users might use them from Emacs just as normal users from
their web browser.  Therefore, bugpile should use the underlying dVCS
to do most of the 'heavy lifting' in processing user queries and then
prepare the result set according to the frontend used.   
</p>
</div>

</div>

<div id="outline-container-search-users-syst-act-design" class="outline-5">
<h5 id="search-users-syst-act-design"><a name="sec-1-2-4-2" id="sec-1-2-4-2"></a>Search Users</h5>
<div class="outline-text-5" id="text-search-users-syst-act-design">


<p>
In contrast to tasks, users are relatively static entities in the bugpile
system, thus it seems unnecessary to rely on the underlying dVCS to answer
queries about users, Emacs and Org-mode functionality should
sufficice. 
</p>
</div>
</div>

</div>

<div id="outline-container-summary-transform-rules" class="outline-4">
<h4 id="summary-transform-rules"><a name="sec-1-2-5" id="sec-1-2-5"></a>Summary of Transformation Rules</h4>
<div class="outline-text-4" id="text-summary-transform-rules">


<p>
The following tables summarize the transformation rules that
transform the results (artefacts) of the software specification into
the software design. 
</p>
<p>
Software oriented activities (SOAs) are transformed with the following
rules:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Software Oriented Activity (SOA)</th><th scope="col" class="left">mapping =&gt; software design</th></tr>
</thead>
<tbody>
<tr><td class="left">use case (SOA diagram)</td><td class="left">/controller/USE-CASE-NAME-controller.el file</td></tr>
<tr><td class="left">use case (SOA diagram)</td><td class="left">/view/USE-CASE-NAME subdirectory</td></tr>
<tr><td class="left">use case with complex logic</td><td class="left">/logic/USE-CASE-NAME-logic.el file</td></tr>
<tr><td class="left">system activity (SA)</td><td class="left">SYSTEM-ACTIVITY-NAME-handler(&hellip;) function in controller file</td></tr>
<tr><td class="left">scene</td><td class="left">USER-ACTIVITY-NAME-scene.org file in /view/USE-CASE-NAME subdirectory</td></tr>
<tr><td class="left">start-node use case (SOA diagram)</td><td class="left">start-USE-CASE-NAME-handler(&hellip;) function in controller file</td></tr>
<tr><td class="left">end-node use case (SOA diagram)</td><td class="left">end-USE-CASE-NAME-handler(&hellip;) function in controller file</td></tr>
</tbody>
</table>


<p>
Complex system activities are transformed with the following
rule:  
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Complex System Activity</th><th scope="col" class="left">mapping =&gt; software design</th></tr>
</thead>
<tbody>
<tr><td class="left">'atomic' system activity (SA)</td><td class="left">SYSTEM-ACTIVITY-NAME-worker(&hellip;) function in logic file</td></tr>
</tbody>
</table>



<p>
The domain class model is transformed with the following
rules: 
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Domain Class Model</th><th scope="col" class="left">mapping =&gt; software design</th></tr>
</thead>
<tbody>
<tr><td class="left">class</td><td class="left">/objects/classes/CLASS-NAME-class.org file with one top-level entry '* CLASS-NAME' with one attribute drawer</td></tr>
<tr><td class="left">attribute</td><td class="left">:attribute: DEFAULT-VALUE in the class attribute drawer</td></tr>
<tr><td class="left">(multiple) inheritance</td><td class="left">superclass name(s) as value(s) of the :super: attribute in the class property drawer</td></tr>
<tr><td class="left">composition</td><td class="left">object name(s) as value(s) of a class attribute in the class attribute drawer</td></tr>
<tr><td class="left">object</td><td class="left">/objects/CLASS-NAME-CUSTOM-ID-obj.org file</td></tr>
</tbody>
</table>




</div>
</div>

</div>

<div id="outline-container-class-model" class="outline-3">
<h3 id="class-model"><a name="sec-1-3" id="sec-1-3"></a>Class Model</h3>
<div class="outline-text-3" id="text-class-model">

<p>Based on the assumption that an Org-mode file can be modeled as a kind
of class hierarchy with inheritance and instantiation, a class model
can be developed for the application. With the file itself (loosly)
interpreted as a kind of abstract root class that can not be
instantiated but has global attributes, and the tree nodes (loosly)
interpreted as class definitions that can be instantiated (several
nodes of the same type at the same tree level) and inherited from
(subnodes), object-oriented design techniques can be applied to
Org-mode files. Of course the similarities only go so far, and do
exist only on the conceptual level. The implementation in Emacs Lisp
is based on functions and (e.g.) lists as data stores that are in no
way encapsulated into formal classes that are part of the language
core.
</p>

</div>

</div>

<div id="outline-container-refine-logic" class="outline-3">
<h3 id="refine-logic"><a name="sec-1-4" id="sec-1-4"></a>Refining the Logic</h3>
<div class="outline-text-3" id="text-refine-logic">

</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-05-26 18:56:14 CEST</p>
<p class="author">Author: Thorsten Jolitz</p>
<p class="creator">Org version 7.8.03 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
